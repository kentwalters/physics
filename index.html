<body>
  <div id="canvas"></div>
    <div id="control"> 
    <!-- <input type="checkbox" /> -->
    <!-- <label>Gravity</label> -->
    <h1 id="obs-label">Objects: </h1>
  </div> -->
  
</body>

<style>
  body {
    margin: 0px;
  }
  #canvas {
    width: 100%;
    height: 100%;
    background-color: #211a10;
  }
  h1 {
      color: #c9ac88;
    }
  .ball {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    background-color: #cb475b;

    position: absolute;
    box-shadow: inset -25px -25px 40px rgba(0, 0, 0, 0.5);
    background-image: -webkit-linear-gradient(
      -45deg,
      rgba(255, 255, 220, 0.2) 0%,
      transparent 100%
    );
    background-image: -moz-linear-gradient(
      -45deg,
      rgba(255, 255, 220, 0.2) 0%,
      transparent 100%
    );
    background-image: -o-linear-gradient(
      -45deg,
      rgba(255, 255, 220, 0.2) 0%,
      transparent 100%
    );
    background-image: -ms-linear-gradient(
      -45deg,
      rgba(255, 255, 220, 0.2) 0%,
      transparent 100%
    );
    
  }
  #control {
    position: absolute;
    margin: 10px;
    top: 0px;
    left: 0px;
  }
  .ball-label {
    font-family: monospace;
    font-weight: bold;
    font-size: 12pt;
  }
</style>

<script>
  // amt of acceleration from gravity
  const GRAVITY_CONST = 1;

  // % of velocity lost in collision with walls
  const COLLISION_ENERGY_LOSS = 0.15;

  // how many times per s we'll re-render
  const FRAME_RATE = 100;

  const ELASTIC_COLLISIONS = true;
  const GRAVITY_ENEABLED = true;

  // array of objects
  const universe = [];
  let canvas = {};

  class Vector {
    // m/s
    velocity;
    // degrees
    direction;

    constructor(m, d) {
      m ? this.velocity = m : this.velocity = 0;
      d ? this.direction = d : this.direction = 0;
    }
  }

  class Ball {
    xPos;
    yPos;
    mass;
    vector;
    htmlElement;

    constructor(x, y, m, v, e) {
      this.xPos = x;
      this.yPos = y;
      this.mass = m;
      this.vector = v;
      this.htmlElement = e;
    }
  }

  const basicSetup = () => {
    canvas = {
      ...{
        html: document.getElementById("canvas"),
        width: window.innerWidth,
        height: window.innerHeight,
      },
    };

    for (let ob of universe) {
      canvas.html.appendChild(ob.ele);
    }

    clickHandler();
  };

  const clickHandler = () => {
    canvas.html.addEventListener("click", (e) => {
      const newHtmlElement = createBallHtmlElement();
      newHtmlElement.style.left = e.clientX - 25 + "px";
      newHtmlElement.style.top = e.clientY - 25 + "px";
      // add new ball to canvas
      canvas.html.appendChild(newHtmlElement);

      const newBallObject = new Ball(
        e.clientX - 25,
        e.clientY - 25,
        100,
        new Vector(Math.random()*400, (2*Math.PI)*Math.random()),
        newHtmlElement
      );
      universe.push(newBallObject);
    });
  };

  const createBallHtmlElement = () => {
    const ball = document.createElement("div");
    ball.classList.add("ball");
    const label = document.createElement('p');
    label.innerText = '';
    ball.appendChild(label)
    label.classList.add('ball-label')
    return ball;
  };

  const start = () => {
    basicSetup();
    setInterval(tick, 1000 / FRAME_RATE);
  };

  const tick = () => {
    move();
    render();
  };

  const move = () => {
    const seconds = 1/FRAME_RATE
    for (let object of universe) {
      const distance = object.vector.velocity * seconds
      let x2 = object.xPos + distance * Math.cos(object.vector.direction)
      let y2 = object.yPos + distance * Math.sin(object.vector.direction)

      // right vertical edge contact
      const rightEdge = x2 >= (canvas.width - 50);
      // console.log(canvas.width, x2)
      const leftEdge  = x2 <= 0
      const top = y2 <= 0;
      const bottomn = y2 >= canvas.height - 50


      if (rightEdge || leftEdge) {
        const piDiff = Math.PI - object.vector.direction
        object.vector.direction =  piDiff 
      } 
      
      if ( top || bottomn) {
        const piDiff = Math.PI - object.vector.direction
        object.vector.direction =  piDiff + Math.PI
      }

      // assign new position to object
      object.xPos = x2;
      object.yPos = y2;





      // if (GRAVITY_ENEABLED) {
      //   ob.dy = ob.dy + GRAVITY_CONST;
      // }

    }
  };

  const render = () => {
    for (let ob of universe) {
      ob.htmlElement.style.left = ob.xPos + "px";
      ob.htmlElement.style.top = ob.yPos + "px";
      ob.htmlElement.firstChild.innerText = ob.vector.direction.toFixed(2)
    }

    document.getElementById('obs-label').innerText = `Objects: ${universe.length}`;
  };

  start();
</script>
